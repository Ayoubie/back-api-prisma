type AggregateCustomer {
  count: Int!
}

type AggregateFilter {
  count: Int!
}

type AggregateItem {
  count: Int!
}

type AggregateMenu {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregateRestaurant {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Customer {
  id: ID!
  first_name: String!
  last_name: String!
  birthday: DateTime!
  telephone: String!
  email: String!
  password: String!
  role: Role
  created: Boolean!
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
}

type CustomerConnection {
  pageInfo: PageInfo!
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  id: ID
  first_name: String!
  last_name: String!
  birthday: DateTime!
  telephone: String!
  email: String!
  password: String!
  role: Role
  created: Boolean
  orders: OrderCreateManyWithoutCustomerInput
}

input CustomerCreateOneWithoutOrdersInput {
  create: CustomerCreateWithoutOrdersInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateWithoutOrdersInput {
  id: ID
  first_name: String!
  last_name: String!
  birthday: DateTime!
  telephone: String!
  email: String!
  password: String!
  role: Role
  created: Boolean
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  first_name_ASC
  first_name_DESC
  last_name_ASC
  last_name_DESC
  birthday_ASC
  birthday_DESC
  telephone_ASC
  telephone_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  role_ASC
  role_DESC
  created_ASC
  created_DESC
}

type CustomerPreviousValues {
  id: ID!
  first_name: String!
  last_name: String!
  birthday: DateTime!
  telephone: String!
  email: String!
  password: String!
  role: Role
  created: Boolean!
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
  AND: [CustomerSubscriptionWhereInput!]
  OR: [CustomerSubscriptionWhereInput!]
  NOT: [CustomerSubscriptionWhereInput!]
}

input CustomerUpdateInput {
  first_name: String
  last_name: String
  birthday: DateTime
  telephone: String
  email: String
  password: String
  role: Role
  created: Boolean
  orders: OrderUpdateManyWithoutCustomerInput
}

input CustomerUpdateManyMutationInput {
  first_name: String
  last_name: String
  birthday: DateTime
  telephone: String
  email: String
  password: String
  role: Role
  created: Boolean
}

input CustomerUpdateOneRequiredWithoutOrdersInput {
  create: CustomerCreateWithoutOrdersInput
  update: CustomerUpdateWithoutOrdersDataInput
  upsert: CustomerUpsertWithoutOrdersInput
  connect: CustomerWhereUniqueInput
}

input CustomerUpdateWithoutOrdersDataInput {
  first_name: String
  last_name: String
  birthday: DateTime
  telephone: String
  email: String
  password: String
  role: Role
  created: Boolean
}

input CustomerUpsertWithoutOrdersInput {
  update: CustomerUpdateWithoutOrdersDataInput!
  create: CustomerCreateWithoutOrdersInput!
}

input CustomerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  first_name: String
  first_name_not: String
  first_name_in: [String!]
  first_name_not_in: [String!]
  first_name_lt: String
  first_name_lte: String
  first_name_gt: String
  first_name_gte: String
  first_name_contains: String
  first_name_not_contains: String
  first_name_starts_with: String
  first_name_not_starts_with: String
  first_name_ends_with: String
  first_name_not_ends_with: String
  last_name: String
  last_name_not: String
  last_name_in: [String!]
  last_name_not_in: [String!]
  last_name_lt: String
  last_name_lte: String
  last_name_gt: String
  last_name_gte: String
  last_name_contains: String
  last_name_not_contains: String
  last_name_starts_with: String
  last_name_not_starts_with: String
  last_name_ends_with: String
  last_name_not_ends_with: String
  birthday: DateTime
  birthday_not: DateTime
  birthday_in: [DateTime!]
  birthday_not_in: [DateTime!]
  birthday_lt: DateTime
  birthday_lte: DateTime
  birthday_gt: DateTime
  birthday_gte: DateTime
  telephone: String
  telephone_not: String
  telephone_in: [String!]
  telephone_not_in: [String!]
  telephone_lt: String
  telephone_lte: String
  telephone_gt: String
  telephone_gte: String
  telephone_contains: String
  telephone_not_contains: String
  telephone_starts_with: String
  telephone_not_starts_with: String
  telephone_ends_with: String
  telephone_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  created: Boolean
  created_not: Boolean
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

input CustomerWhereUniqueInput {
  id: ID
  telephone: String
  email: String
}

scalar DateTime

type Filter {
  id: ID!
  name: String!
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  menus(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu!]
  restaurants(where: RestaurantWhereInput, orderBy: RestaurantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Restaurant!]
}

type FilterConnection {
  pageInfo: PageInfo!
  edges: [FilterEdge]!
  aggregate: AggregateFilter!
}

input FilterCreateInput {
  id: ID
  name: String!
  items: ItemCreateManyWithoutFiltersInput
  menus: MenuCreateManyWithoutFiltersInput
  restaurants: RestaurantCreateManyWithoutFiltersInput
}

input FilterCreateManyWithoutItemsInput {
  create: [FilterCreateWithoutItemsInput!]
  connect: [FilterWhereUniqueInput!]
}

input FilterCreateManyWithoutMenusInput {
  create: [FilterCreateWithoutMenusInput!]
  connect: [FilterWhereUniqueInput!]
}

input FilterCreateManyWithoutRestaurantsInput {
  create: [FilterCreateWithoutRestaurantsInput!]
  connect: [FilterWhereUniqueInput!]
}

input FilterCreateWithoutItemsInput {
  id: ID
  name: String!
  menus: MenuCreateManyWithoutFiltersInput
  restaurants: RestaurantCreateManyWithoutFiltersInput
}

input FilterCreateWithoutMenusInput {
  id: ID
  name: String!
  items: ItemCreateManyWithoutFiltersInput
  restaurants: RestaurantCreateManyWithoutFiltersInput
}

input FilterCreateWithoutRestaurantsInput {
  id: ID
  name: String!
  items: ItemCreateManyWithoutFiltersInput
  menus: MenuCreateManyWithoutFiltersInput
}

type FilterEdge {
  node: Filter!
  cursor: String!
}

enum FilterOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type FilterPreviousValues {
  id: ID!
  name: String!
}

input FilterScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [FilterScalarWhereInput!]
  OR: [FilterScalarWhereInput!]
  NOT: [FilterScalarWhereInput!]
}

type FilterSubscriptionPayload {
  mutation: MutationType!
  node: Filter
  updatedFields: [String!]
  previousValues: FilterPreviousValues
}

input FilterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FilterWhereInput
  AND: [FilterSubscriptionWhereInput!]
  OR: [FilterSubscriptionWhereInput!]
  NOT: [FilterSubscriptionWhereInput!]
}

input FilterUpdateInput {
  name: String
  items: ItemUpdateManyWithoutFiltersInput
  menus: MenuUpdateManyWithoutFiltersInput
  restaurants: RestaurantUpdateManyWithoutFiltersInput
}

input FilterUpdateManyDataInput {
  name: String
}

input FilterUpdateManyMutationInput {
  name: String
}

input FilterUpdateManyWithoutItemsInput {
  create: [FilterCreateWithoutItemsInput!]
  delete: [FilterWhereUniqueInput!]
  connect: [FilterWhereUniqueInput!]
  set: [FilterWhereUniqueInput!]
  disconnect: [FilterWhereUniqueInput!]
  update: [FilterUpdateWithWhereUniqueWithoutItemsInput!]
  upsert: [FilterUpsertWithWhereUniqueWithoutItemsInput!]
  deleteMany: [FilterScalarWhereInput!]
  updateMany: [FilterUpdateManyWithWhereNestedInput!]
}

input FilterUpdateManyWithoutMenusInput {
  create: [FilterCreateWithoutMenusInput!]
  delete: [FilterWhereUniqueInput!]
  connect: [FilterWhereUniqueInput!]
  set: [FilterWhereUniqueInput!]
  disconnect: [FilterWhereUniqueInput!]
  update: [FilterUpdateWithWhereUniqueWithoutMenusInput!]
  upsert: [FilterUpsertWithWhereUniqueWithoutMenusInput!]
  deleteMany: [FilterScalarWhereInput!]
  updateMany: [FilterUpdateManyWithWhereNestedInput!]
}

input FilterUpdateManyWithoutRestaurantsInput {
  create: [FilterCreateWithoutRestaurantsInput!]
  delete: [FilterWhereUniqueInput!]
  connect: [FilterWhereUniqueInput!]
  set: [FilterWhereUniqueInput!]
  disconnect: [FilterWhereUniqueInput!]
  update: [FilterUpdateWithWhereUniqueWithoutRestaurantsInput!]
  upsert: [FilterUpsertWithWhereUniqueWithoutRestaurantsInput!]
  deleteMany: [FilterScalarWhereInput!]
  updateMany: [FilterUpdateManyWithWhereNestedInput!]
}

input FilterUpdateManyWithWhereNestedInput {
  where: FilterScalarWhereInput!
  data: FilterUpdateManyDataInput!
}

input FilterUpdateWithoutItemsDataInput {
  name: String
  menus: MenuUpdateManyWithoutFiltersInput
  restaurants: RestaurantUpdateManyWithoutFiltersInput
}

input FilterUpdateWithoutMenusDataInput {
  name: String
  items: ItemUpdateManyWithoutFiltersInput
  restaurants: RestaurantUpdateManyWithoutFiltersInput
}

input FilterUpdateWithoutRestaurantsDataInput {
  name: String
  items: ItemUpdateManyWithoutFiltersInput
  menus: MenuUpdateManyWithoutFiltersInput
}

input FilterUpdateWithWhereUniqueWithoutItemsInput {
  where: FilterWhereUniqueInput!
  data: FilterUpdateWithoutItemsDataInput!
}

input FilterUpdateWithWhereUniqueWithoutMenusInput {
  where: FilterWhereUniqueInput!
  data: FilterUpdateWithoutMenusDataInput!
}

input FilterUpdateWithWhereUniqueWithoutRestaurantsInput {
  where: FilterWhereUniqueInput!
  data: FilterUpdateWithoutRestaurantsDataInput!
}

input FilterUpsertWithWhereUniqueWithoutItemsInput {
  where: FilterWhereUniqueInput!
  update: FilterUpdateWithoutItemsDataInput!
  create: FilterCreateWithoutItemsInput!
}

input FilterUpsertWithWhereUniqueWithoutMenusInput {
  where: FilterWhereUniqueInput!
  update: FilterUpdateWithoutMenusDataInput!
  create: FilterCreateWithoutMenusInput!
}

input FilterUpsertWithWhereUniqueWithoutRestaurantsInput {
  where: FilterWhereUniqueInput!
  update: FilterUpdateWithoutRestaurantsDataInput!
  create: FilterCreateWithoutRestaurantsInput!
}

input FilterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  menus_every: MenuWhereInput
  menus_some: MenuWhereInput
  menus_none: MenuWhereInput
  restaurants_every: RestaurantWhereInput
  restaurants_some: RestaurantWhereInput
  restaurants_none: RestaurantWhereInput
  AND: [FilterWhereInput!]
  OR: [FilterWhereInput!]
  NOT: [FilterWhereInput!]
}

input FilterWhereUniqueInput {
  id: ID
  name: String
}

type Item {
  id: ID!
  title: String!
  price: Int
  restaurants(where: RestaurantWhereInput, orderBy: RestaurantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Restaurant!]
  filters(where: FilterWhereInput, orderBy: FilterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Filter!]
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  id: ID
  title: String!
  price: Int
  restaurants: RestaurantCreateManyWithoutItemsInput
  filters: FilterCreateManyWithoutItemsInput
}

input ItemCreateManyInput {
  create: [ItemCreateInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateManyWithoutFiltersInput {
  create: [ItemCreateWithoutFiltersInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateManyWithoutRestaurantsInput {
  create: [ItemCreateWithoutRestaurantsInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateWithoutFiltersInput {
  id: ID
  title: String!
  price: Int
  restaurants: RestaurantCreateManyWithoutItemsInput
}

input ItemCreateWithoutRestaurantsInput {
  id: ID
  title: String!
  price: Int
  filters: FilterCreateManyWithoutItemsInput
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  price_ASC
  price_DESC
}

type ItemPreviousValues {
  id: ID!
  title: String!
  price: Int
}

input ItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateDataInput {
  title: String
  price: Int
  restaurants: RestaurantUpdateManyWithoutItemsInput
  filters: FilterUpdateManyWithoutItemsInput
}

input ItemUpdateInput {
  title: String
  price: Int
  restaurants: RestaurantUpdateManyWithoutItemsInput
  filters: FilterUpdateManyWithoutItemsInput
}

input ItemUpdateManyDataInput {
  title: String
  price: Int
}

input ItemUpdateManyInput {
  create: [ItemCreateInput!]
  update: [ItemUpdateWithWhereUniqueNestedInput!]
  upsert: [ItemUpsertWithWhereUniqueNestedInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyMutationInput {
  title: String
  price: Int
}

input ItemUpdateManyWithoutFiltersInput {
  create: [ItemCreateWithoutFiltersInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutFiltersInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutFiltersInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithoutRestaurantsInput {
  create: [ItemCreateWithoutRestaurantsInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutRestaurantsInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutRestaurantsInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemUpdateWithoutFiltersDataInput {
  title: String
  price: Int
  restaurants: RestaurantUpdateManyWithoutItemsInput
}

input ItemUpdateWithoutRestaurantsDataInput {
  title: String
  price: Int
  filters: FilterUpdateManyWithoutItemsInput
}

input ItemUpdateWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateDataInput!
}

input ItemUpdateWithWhereUniqueWithoutFiltersInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutFiltersDataInput!
}

input ItemUpdateWithWhereUniqueWithoutRestaurantsInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutRestaurantsDataInput!
}

input ItemUpsertWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateDataInput!
  create: ItemCreateInput!
}

input ItemUpsertWithWhereUniqueWithoutFiltersInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutFiltersDataInput!
  create: ItemCreateWithoutFiltersInput!
}

input ItemUpsertWithWhereUniqueWithoutRestaurantsInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutRestaurantsDataInput!
  create: ItemCreateWithoutRestaurantsInput!
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  restaurants_every: RestaurantWhereInput
  restaurants_some: RestaurantWhereInput
  restaurants_none: RestaurantWhereInput
  filters_every: FilterWhereInput
  filters_some: FilterWhereInput
  filters_none: FilterWhereInput
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
}

scalar Long

type Menu {
  id: ID!
  title: String!
  price: Int
  restaurants(where: RestaurantWhereInput, orderBy: RestaurantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Restaurant!]
  filters(where: FilterWhereInput, orderBy: FilterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Filter!]
}

type MenuConnection {
  pageInfo: PageInfo!
  edges: [MenuEdge]!
  aggregate: AggregateMenu!
}

input MenuCreateInput {
  id: ID
  title: String!
  price: Int
  restaurants: RestaurantCreateManyWithoutMenusInput
  filters: FilterCreateManyWithoutMenusInput
}

input MenuCreateManyInput {
  create: [MenuCreateInput!]
  connect: [MenuWhereUniqueInput!]
}

input MenuCreateManyWithoutFiltersInput {
  create: [MenuCreateWithoutFiltersInput!]
  connect: [MenuWhereUniqueInput!]
}

input MenuCreateManyWithoutRestaurantsInput {
  create: [MenuCreateWithoutRestaurantsInput!]
  connect: [MenuWhereUniqueInput!]
}

input MenuCreateWithoutFiltersInput {
  id: ID
  title: String!
  price: Int
  restaurants: RestaurantCreateManyWithoutMenusInput
}

input MenuCreateWithoutRestaurantsInput {
  id: ID
  title: String!
  price: Int
  filters: FilterCreateManyWithoutMenusInput
}

type MenuEdge {
  node: Menu!
  cursor: String!
}

enum MenuOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  price_ASC
  price_DESC
}

type MenuPreviousValues {
  id: ID!
  title: String!
  price: Int
}

input MenuScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  AND: [MenuScalarWhereInput!]
  OR: [MenuScalarWhereInput!]
  NOT: [MenuScalarWhereInput!]
}

type MenuSubscriptionPayload {
  mutation: MutationType!
  node: Menu
  updatedFields: [String!]
  previousValues: MenuPreviousValues
}

input MenuSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MenuWhereInput
  AND: [MenuSubscriptionWhereInput!]
  OR: [MenuSubscriptionWhereInput!]
  NOT: [MenuSubscriptionWhereInput!]
}

input MenuUpdateDataInput {
  title: String
  price: Int
  restaurants: RestaurantUpdateManyWithoutMenusInput
  filters: FilterUpdateManyWithoutMenusInput
}

input MenuUpdateInput {
  title: String
  price: Int
  restaurants: RestaurantUpdateManyWithoutMenusInput
  filters: FilterUpdateManyWithoutMenusInput
}

input MenuUpdateManyDataInput {
  title: String
  price: Int
}

input MenuUpdateManyInput {
  create: [MenuCreateInput!]
  update: [MenuUpdateWithWhereUniqueNestedInput!]
  upsert: [MenuUpsertWithWhereUniqueNestedInput!]
  delete: [MenuWhereUniqueInput!]
  connect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  disconnect: [MenuWhereUniqueInput!]
  deleteMany: [MenuScalarWhereInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
}

input MenuUpdateManyMutationInput {
  title: String
  price: Int
}

input MenuUpdateManyWithoutFiltersInput {
  create: [MenuCreateWithoutFiltersInput!]
  delete: [MenuWhereUniqueInput!]
  connect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  disconnect: [MenuWhereUniqueInput!]
  update: [MenuUpdateWithWhereUniqueWithoutFiltersInput!]
  upsert: [MenuUpsertWithWhereUniqueWithoutFiltersInput!]
  deleteMany: [MenuScalarWhereInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
}

input MenuUpdateManyWithoutRestaurantsInput {
  create: [MenuCreateWithoutRestaurantsInput!]
  delete: [MenuWhereUniqueInput!]
  connect: [MenuWhereUniqueInput!]
  set: [MenuWhereUniqueInput!]
  disconnect: [MenuWhereUniqueInput!]
  update: [MenuUpdateWithWhereUniqueWithoutRestaurantsInput!]
  upsert: [MenuUpsertWithWhereUniqueWithoutRestaurantsInput!]
  deleteMany: [MenuScalarWhereInput!]
  updateMany: [MenuUpdateManyWithWhereNestedInput!]
}

input MenuUpdateManyWithWhereNestedInput {
  where: MenuScalarWhereInput!
  data: MenuUpdateManyDataInput!
}

input MenuUpdateWithoutFiltersDataInput {
  title: String
  price: Int
  restaurants: RestaurantUpdateManyWithoutMenusInput
}

input MenuUpdateWithoutRestaurantsDataInput {
  title: String
  price: Int
  filters: FilterUpdateManyWithoutMenusInput
}

input MenuUpdateWithWhereUniqueNestedInput {
  where: MenuWhereUniqueInput!
  data: MenuUpdateDataInput!
}

input MenuUpdateWithWhereUniqueWithoutFiltersInput {
  where: MenuWhereUniqueInput!
  data: MenuUpdateWithoutFiltersDataInput!
}

input MenuUpdateWithWhereUniqueWithoutRestaurantsInput {
  where: MenuWhereUniqueInput!
  data: MenuUpdateWithoutRestaurantsDataInput!
}

input MenuUpsertWithWhereUniqueNestedInput {
  where: MenuWhereUniqueInput!
  update: MenuUpdateDataInput!
  create: MenuCreateInput!
}

input MenuUpsertWithWhereUniqueWithoutFiltersInput {
  where: MenuWhereUniqueInput!
  update: MenuUpdateWithoutFiltersDataInput!
  create: MenuCreateWithoutFiltersInput!
}

input MenuUpsertWithWhereUniqueWithoutRestaurantsInput {
  where: MenuWhereUniqueInput!
  update: MenuUpdateWithoutRestaurantsDataInput!
  create: MenuCreateWithoutRestaurantsInput!
}

input MenuWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  price: Int
  price_not: Int
  price_in: [Int!]
  price_not_in: [Int!]
  price_lt: Int
  price_lte: Int
  price_gt: Int
  price_gte: Int
  restaurants_every: RestaurantWhereInput
  restaurants_some: RestaurantWhereInput
  restaurants_none: RestaurantWhereInput
  filters_every: FilterWhereInput
  filters_some: FilterWhereInput
  filters_none: FilterWhereInput
  AND: [MenuWhereInput!]
  OR: [MenuWhereInput!]
  NOT: [MenuWhereInput!]
}

input MenuWhereUniqueInput {
  id: ID
}

type Mutation {
  createCustomer(data: CustomerCreateInput!): Customer!
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateManyCustomers(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): BatchPayload!
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  createFilter(data: FilterCreateInput!): Filter!
  updateFilter(data: FilterUpdateInput!, where: FilterWhereUniqueInput!): Filter
  updateManyFilters(data: FilterUpdateManyMutationInput!, where: FilterWhereInput): BatchPayload!
  upsertFilter(where: FilterWhereUniqueInput!, create: FilterCreateInput!, update: FilterUpdateInput!): Filter!
  deleteFilter(where: FilterWhereUniqueInput!): Filter
  deleteManyFilters(where: FilterWhereInput): BatchPayload!
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createMenu(data: MenuCreateInput!): Menu!
  updateMenu(data: MenuUpdateInput!, where: MenuWhereUniqueInput!): Menu
  updateManyMenus(data: MenuUpdateManyMutationInput!, where: MenuWhereInput): BatchPayload!
  upsertMenu(where: MenuWhereUniqueInput!, create: MenuCreateInput!, update: MenuUpdateInput!): Menu!
  deleteMenu(where: MenuWhereUniqueInput!): Menu
  deleteManyMenus(where: MenuWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createRestaurant(data: RestaurantCreateInput!): Restaurant!
  updateRestaurant(data: RestaurantUpdateInput!, where: RestaurantWhereUniqueInput!): Restaurant
  updateManyRestaurants(data: RestaurantUpdateManyMutationInput!, where: RestaurantWhereInput): BatchPayload!
  upsertRestaurant(where: RestaurantWhereUniqueInput!, create: RestaurantCreateInput!, update: RestaurantUpdateInput!): Restaurant!
  deleteRestaurant(where: RestaurantWhereUniqueInput!): Restaurant
  deleteManyRestaurants(where: RestaurantWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Order {
  id: ID!
  status: Boolean!
  menus(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu!]
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  customer: Customer!
  payment: Payment!
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
  status: Boolean!
  menus: MenuCreateManyInput
  items: ItemCreateManyInput
  customer: CustomerCreateOneWithoutOrdersInput!
  payment: PaymentCreateOneWithoutOrderInput!
}

input OrderCreateManyWithoutCustomerInput {
  create: [OrderCreateWithoutCustomerInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateOneWithoutPaymentInput {
  create: OrderCreateWithoutPaymentInput
  connect: OrderWhereUniqueInput
}

input OrderCreateWithoutCustomerInput {
  id: ID
  status: Boolean!
  menus: MenuCreateManyInput
  items: ItemCreateManyInput
  payment: PaymentCreateOneWithoutOrderInput!
}

input OrderCreateWithoutPaymentInput {
  id: ID
  status: Boolean!
  menus: MenuCreateManyInput
  items: ItemCreateManyInput
  customer: CustomerCreateOneWithoutOrdersInput!
}

type OrderEdge {
  node: Order!
  cursor: String!
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
}

type OrderPreviousValues {
  id: ID!
  status: Boolean!
}

input OrderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: Boolean
  status_not: Boolean
  AND: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  NOT: [OrderScalarWhereInput!]
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateInput {
  status: Boolean
  menus: MenuUpdateManyInput
  items: ItemUpdateManyInput
  customer: CustomerUpdateOneRequiredWithoutOrdersInput
  payment: PaymentUpdateOneRequiredWithoutOrderInput
}

input OrderUpdateManyDataInput {
  status: Boolean
}

input OrderUpdateManyMutationInput {
  status: Boolean
}

input OrderUpdateManyWithoutCustomerInput {
  create: [OrderCreateWithoutCustomerInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutCustomerInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutCustomerInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput!
  data: OrderUpdateManyDataInput!
}

input OrderUpdateOneRequiredWithoutPaymentInput {
  create: OrderCreateWithoutPaymentInput
  update: OrderUpdateWithoutPaymentDataInput
  upsert: OrderUpsertWithoutPaymentInput
  connect: OrderWhereUniqueInput
}

input OrderUpdateWithoutCustomerDataInput {
  status: Boolean
  menus: MenuUpdateManyInput
  items: ItemUpdateManyInput
  payment: PaymentUpdateOneRequiredWithoutOrderInput
}

input OrderUpdateWithoutPaymentDataInput {
  status: Boolean
  menus: MenuUpdateManyInput
  items: ItemUpdateManyInput
  customer: CustomerUpdateOneRequiredWithoutOrdersInput
}

input OrderUpdateWithWhereUniqueWithoutCustomerInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutCustomerDataInput!
}

input OrderUpsertWithoutPaymentInput {
  update: OrderUpdateWithoutPaymentDataInput!
  create: OrderCreateWithoutPaymentInput!
}

input OrderUpsertWithWhereUniqueWithoutCustomerInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutCustomerDataInput!
  create: OrderCreateWithoutCustomerInput!
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: Boolean
  status_not: Boolean
  menus_every: MenuWhereInput
  menus_some: MenuWhereInput
  menus_none: MenuWhereInput
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  customer: CustomerWhereInput
  payment: PaymentWhereInput
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  amount: Float!
  status: Boolean!
  type: String!
  codePayment: String!
  order: Order!
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  id: ID
  amount: Float!
  status: Boolean!
  type: String!
  codePayment: String!
  order: OrderCreateOneWithoutPaymentInput!
}

input PaymentCreateOneWithoutOrderInput {
  create: PaymentCreateWithoutOrderInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutOrderInput {
  id: ID
  amount: Float!
  status: Boolean!
  type: String!
  codePayment: String!
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  status_ASC
  status_DESC
  type_ASC
  type_DESC
  codePayment_ASC
  codePayment_DESC
}

type PaymentPreviousValues {
  id: ID!
  amount: Float!
  status: Boolean!
  type: String!
  codePayment: String!
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  amount: Float
  status: Boolean
  type: String
  codePayment: String
  order: OrderUpdateOneRequiredWithoutPaymentInput
}

input PaymentUpdateManyMutationInput {
  amount: Float
  status: Boolean
  type: String
  codePayment: String
}

input PaymentUpdateOneRequiredWithoutOrderInput {
  create: PaymentCreateWithoutOrderInput
  update: PaymentUpdateWithoutOrderDataInput
  upsert: PaymentUpsertWithoutOrderInput
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutOrderDataInput {
  amount: Float
  status: Boolean
  type: String
  codePayment: String
}

input PaymentUpsertWithoutOrderInput {
  update: PaymentUpdateWithoutOrderDataInput!
  create: PaymentCreateWithoutOrderInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  status: Boolean
  status_not: Boolean
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  codePayment: String
  codePayment_not: String
  codePayment_in: [String!]
  codePayment_not_in: [String!]
  codePayment_lt: String
  codePayment_lte: String
  codePayment_gt: String
  codePayment_gte: String
  codePayment_contains: String
  codePayment_not_contains: String
  codePayment_starts_with: String
  codePayment_not_starts_with: String
  codePayment_ends_with: String
  codePayment_not_ends_with: String
  order: OrderWhereInput
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
  codePayment: String
}

type Query {
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  filter(where: FilterWhereUniqueInput!): Filter
  filters(where: FilterWhereInput, orderBy: FilterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Filter]!
  filtersConnection(where: FilterWhereInput, orderBy: FilterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FilterConnection!
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  menu(where: MenuWhereUniqueInput!): Menu
  menus(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu]!
  menusConnection(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MenuConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  restaurant(where: RestaurantWhereUniqueInput!): Restaurant
  restaurants(where: RestaurantWhereInput, orderBy: RestaurantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Restaurant]!
  restaurantsConnection(where: RestaurantWhereInput, orderBy: RestaurantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RestaurantConnection!
  node(id: ID!): Node
}

type Restaurant {
  id: ID!
  name: String!
  description: String!
  created: Boolean!
  menus(where: MenuWhereInput, orderBy: MenuOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Menu!]
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  filters(where: FilterWhereInput, orderBy: FilterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Filter!]
}

type RestaurantConnection {
  pageInfo: PageInfo!
  edges: [RestaurantEdge]!
  aggregate: AggregateRestaurant!
}

input RestaurantCreateInput {
  id: ID
  name: String!
  description: String!
  created: Boolean
  menus: MenuCreateManyWithoutRestaurantsInput
  items: ItemCreateManyWithoutRestaurantsInput
  filters: FilterCreateManyWithoutRestaurantsInput
}

input RestaurantCreateManyWithoutFiltersInput {
  create: [RestaurantCreateWithoutFiltersInput!]
  connect: [RestaurantWhereUniqueInput!]
}

input RestaurantCreateManyWithoutItemsInput {
  create: [RestaurantCreateWithoutItemsInput!]
  connect: [RestaurantWhereUniqueInput!]
}

input RestaurantCreateManyWithoutMenusInput {
  create: [RestaurantCreateWithoutMenusInput!]
  connect: [RestaurantWhereUniqueInput!]
}

input RestaurantCreateWithoutFiltersInput {
  id: ID
  name: String!
  description: String!
  created: Boolean
  menus: MenuCreateManyWithoutRestaurantsInput
  items: ItemCreateManyWithoutRestaurantsInput
}

input RestaurantCreateWithoutItemsInput {
  id: ID
  name: String!
  description: String!
  created: Boolean
  menus: MenuCreateManyWithoutRestaurantsInput
  filters: FilterCreateManyWithoutRestaurantsInput
}

input RestaurantCreateWithoutMenusInput {
  id: ID
  name: String!
  description: String!
  created: Boolean
  items: ItemCreateManyWithoutRestaurantsInput
  filters: FilterCreateManyWithoutRestaurantsInput
}

type RestaurantEdge {
  node: Restaurant!
  cursor: String!
}

enum RestaurantOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  created_ASC
  created_DESC
}

type RestaurantPreviousValues {
  id: ID!
  name: String!
  description: String!
  created: Boolean!
}

input RestaurantScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  created: Boolean
  created_not: Boolean
  AND: [RestaurantScalarWhereInput!]
  OR: [RestaurantScalarWhereInput!]
  NOT: [RestaurantScalarWhereInput!]
}

type RestaurantSubscriptionPayload {
  mutation: MutationType!
  node: Restaurant
  updatedFields: [String!]
  previousValues: RestaurantPreviousValues
}

input RestaurantSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RestaurantWhereInput
  AND: [RestaurantSubscriptionWhereInput!]
  OR: [RestaurantSubscriptionWhereInput!]
  NOT: [RestaurantSubscriptionWhereInput!]
}

input RestaurantUpdateInput {
  name: String
  description: String
  created: Boolean
  menus: MenuUpdateManyWithoutRestaurantsInput
  items: ItemUpdateManyWithoutRestaurantsInput
  filters: FilterUpdateManyWithoutRestaurantsInput
}

input RestaurantUpdateManyDataInput {
  name: String
  description: String
  created: Boolean
}

input RestaurantUpdateManyMutationInput {
  name: String
  description: String
  created: Boolean
}

input RestaurantUpdateManyWithoutFiltersInput {
  create: [RestaurantCreateWithoutFiltersInput!]
  delete: [RestaurantWhereUniqueInput!]
  connect: [RestaurantWhereUniqueInput!]
  set: [RestaurantWhereUniqueInput!]
  disconnect: [RestaurantWhereUniqueInput!]
  update: [RestaurantUpdateWithWhereUniqueWithoutFiltersInput!]
  upsert: [RestaurantUpsertWithWhereUniqueWithoutFiltersInput!]
  deleteMany: [RestaurantScalarWhereInput!]
  updateMany: [RestaurantUpdateManyWithWhereNestedInput!]
}

input RestaurantUpdateManyWithoutItemsInput {
  create: [RestaurantCreateWithoutItemsInput!]
  delete: [RestaurantWhereUniqueInput!]
  connect: [RestaurantWhereUniqueInput!]
  set: [RestaurantWhereUniqueInput!]
  disconnect: [RestaurantWhereUniqueInput!]
  update: [RestaurantUpdateWithWhereUniqueWithoutItemsInput!]
  upsert: [RestaurantUpsertWithWhereUniqueWithoutItemsInput!]
  deleteMany: [RestaurantScalarWhereInput!]
  updateMany: [RestaurantUpdateManyWithWhereNestedInput!]
}

input RestaurantUpdateManyWithoutMenusInput {
  create: [RestaurantCreateWithoutMenusInput!]
  delete: [RestaurantWhereUniqueInput!]
  connect: [RestaurantWhereUniqueInput!]
  set: [RestaurantWhereUniqueInput!]
  disconnect: [RestaurantWhereUniqueInput!]
  update: [RestaurantUpdateWithWhereUniqueWithoutMenusInput!]
  upsert: [RestaurantUpsertWithWhereUniqueWithoutMenusInput!]
  deleteMany: [RestaurantScalarWhereInput!]
  updateMany: [RestaurantUpdateManyWithWhereNestedInput!]
}

input RestaurantUpdateManyWithWhereNestedInput {
  where: RestaurantScalarWhereInput!
  data: RestaurantUpdateManyDataInput!
}

input RestaurantUpdateWithoutFiltersDataInput {
  name: String
  description: String
  created: Boolean
  menus: MenuUpdateManyWithoutRestaurantsInput
  items: ItemUpdateManyWithoutRestaurantsInput
}

input RestaurantUpdateWithoutItemsDataInput {
  name: String
  description: String
  created: Boolean
  menus: MenuUpdateManyWithoutRestaurantsInput
  filters: FilterUpdateManyWithoutRestaurantsInput
}

input RestaurantUpdateWithoutMenusDataInput {
  name: String
  description: String
  created: Boolean
  items: ItemUpdateManyWithoutRestaurantsInput
  filters: FilterUpdateManyWithoutRestaurantsInput
}

input RestaurantUpdateWithWhereUniqueWithoutFiltersInput {
  where: RestaurantWhereUniqueInput!
  data: RestaurantUpdateWithoutFiltersDataInput!
}

input RestaurantUpdateWithWhereUniqueWithoutItemsInput {
  where: RestaurantWhereUniqueInput!
  data: RestaurantUpdateWithoutItemsDataInput!
}

input RestaurantUpdateWithWhereUniqueWithoutMenusInput {
  where: RestaurantWhereUniqueInput!
  data: RestaurantUpdateWithoutMenusDataInput!
}

input RestaurantUpsertWithWhereUniqueWithoutFiltersInput {
  where: RestaurantWhereUniqueInput!
  update: RestaurantUpdateWithoutFiltersDataInput!
  create: RestaurantCreateWithoutFiltersInput!
}

input RestaurantUpsertWithWhereUniqueWithoutItemsInput {
  where: RestaurantWhereUniqueInput!
  update: RestaurantUpdateWithoutItemsDataInput!
  create: RestaurantCreateWithoutItemsInput!
}

input RestaurantUpsertWithWhereUniqueWithoutMenusInput {
  where: RestaurantWhereUniqueInput!
  update: RestaurantUpdateWithoutMenusDataInput!
  create: RestaurantCreateWithoutMenusInput!
}

input RestaurantWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  created: Boolean
  created_not: Boolean
  menus_every: MenuWhereInput
  menus_some: MenuWhereInput
  menus_none: MenuWhereInput
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  filters_every: FilterWhereInput
  filters_some: FilterWhereInput
  filters_none: FilterWhereInput
  AND: [RestaurantWhereInput!]
  OR: [RestaurantWhereInput!]
  NOT: [RestaurantWhereInput!]
}

input RestaurantWhereUniqueInput {
  id: ID
  name: String
}

enum Role {
  ADMIN
  CUSTOMER
  RESTORER
}

type Subscription {
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  filter(where: FilterSubscriptionWhereInput): FilterSubscriptionPayload
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  menu(where: MenuSubscriptionWhereInput): MenuSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  restaurant(where: RestaurantSubscriptionWhereInput): RestaurantSubscriptionPayload
}
